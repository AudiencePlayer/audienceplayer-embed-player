{"version":3,"file":"logging.js","mappings":"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","sources":["webpack://audienceplayer-embed-player/webpack/bootstrap","webpack://audienceplayer-embed-player/./src/models/play-config.ts","webpack://audienceplayer-embed-player/webpack/runtime/define property getters","webpack://audienceplayer-embed-player/webpack/runtime/hasOwnProperty shorthand","webpack://audienceplayer-embed-player/./src/api/graph-request.ts","webpack://audienceplayer-embed-player/./src/api/converters.ts","webpack://audienceplayer-embed-player/./src/api/api-service.ts","webpack://audienceplayer-embed-player/./src/api/queries.ts","webpack://audienceplayer-embed-player/./src/models/player.ts","webpack://audienceplayer-embed-player/./src/models/play-params.ts","webpack://audienceplayer-embed-player/./src/logging/player-log-processor.ts","webpack://audienceplayer-embed-player/./src/logging/player-logger-service.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","export interface PlayConfig {\n    pulseToken: string;\n    currentTime: number;\n    entitlements: PlayEntitlement[];\n    subtitles: PlayConfigSubtitle[];\n    articleId?: number;\n    assetId: number;\n    subtitleLocale: string;\n    audioLocale: string;\n    aspectRatio: string;\n    localTimeDelta?: number;\n    skipIntro?: {\n        start: number;\n        end: number;\n        label: string;\n    };\n    continuePaused?: boolean;\n}\n\nexport interface PlayEntitlement {\n    src: string;\n    type: MimeType;\n    isLive: boolean;\n    protectionInfo: PlayConfigProtection[] | null;\n    mediaProvider: string;\n}\n\nexport interface PlayConfigSubtitle {\n    src: string;\n    srclang: string;\n    kind: string;\n    label: string;\n}\n\nexport interface PlayConfigProtection {\n    type: DrmType;\n    authenticationToken?: string;\n    certificateUrl?: string;\n    keyDeliveryUrl: string;\n    encryptionProvider: string;\n    contentKeyId?: string;\n}\n\nexport enum ArticlePlayErrors {\n    noPlayableAsset = 'noPlayableAsset',\n    notAuthenticated = 'notAuthenticated',\n    needEntitlement = 'needEntitlement',\n    serverError = 'serverError',\n    offlineError = 'offlineError',\n    maxConcurrentStreamNumberError = 'maxConcurrentStreamNumberError',\n}\n\nexport type DrmType = 'Widevine' | 'PlayReady' | 'FairPlay';\nexport type MimeType = 'application/x-mpegURL' | 'application/dash+xml' | 'video/mp4';\nexport const MimeTypeHls = 'application/x-mpegURL';\nexport const MimeTypeDash = 'application/dash+xml';\nexport const MimeTypeMp4 = 'video/mp4';\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function graphRequest(apiFetchUrl: string, query: string, variables: any, token: string) {\n    const authHeader = token ? {Authorization: 'Bearer ' + token} : {};\n\n    return fetch(apiFetchUrl, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            Accept: 'application/json',\n            ...authHeader,\n        },\n        body: JSON.stringify({\n            query,\n            variables,\n        }),\n    }).then(response => response.json());\n}\n","import {PlayConfig, PlayEntitlement, ArticlePlayErrors, MimeType, MimeTypeHls, MimeTypeDash, MimeTypeMp4} from '../models/play-config';\nimport {Article} from '../models/article';\nimport {FileData} from '../models/file-data';\nimport {PlayParams} from \"../models/play-params\";\n\nexport function toPlayConfig(config: any, playParams: PlayParams): PlayConfig {\n    const timeStamp = Date.parse(config.issued_at);\n    const entitlements: PlayEntitlement[] = [];\n\n    // check if the entitlements contain FPS in order to know when to filter out aes\n    const filterAES = !!config.entitlements.find((entitlement: any) => entitlement.encryption_type === 'fps');\n    const configEntitlements = filterAES\n        ? config.entitlements.filter((entitlement: any) => {\n              return entitlement.encryption_type !== 'aes';\n          })\n        : config.entitlements;\n\n    configEntitlements.forEach((entitlement: any) => {\n        const entitlementConfig: PlayEntitlement = {\n            src: entitlement.manifest,\n            type: toMimeType(entitlement.mime_type),\n            isLive: entitlement.is_live,\n            protectionInfo: null,\n            mediaProvider: entitlement.media_provider,\n        };\n\n        if (entitlement.encryption_type) {\n            if (entitlement.encryption_type === 'cenc' && entitlement.protocol.indexOf('dash') === 0) {\n                entitlementConfig.protectionInfo = [\n                    {\n                        type: 'Widevine',\n                        authenticationToken:\n                            entitlement.encryption_provider === 'azl' && !!entitlement.token ? 'Bearer ' + entitlement.token : '',\n                        keyDeliveryUrl: entitlement.key_delivery_url,\n                        encryptionProvider: entitlement.encryption_provider,\n                    },\n                ];\n            } else if (entitlement.encryption_type === 'fps' && entitlement.protocol.indexOf('hls') === 0) {\n                entitlementConfig.protectionInfo = [\n                    {\n                        type: 'FairPlay',\n                        authenticationToken:\n                            entitlement.encryption_provider === 'azl' && !!entitlement.token ? 'Bearer ' + entitlement.token : '',\n                        certificateUrl: config.fairplay_certificate_url,\n                        keyDeliveryUrl: entitlement.key_delivery_url,\n                        encryptionProvider: entitlement.encryption_provider,\n                        contentKeyId:\n                            entitlement.encryption_provider === 'azl'\n                                ? entitlement.key_delivery_url.replace('https://', 'skd://')\n                                : entitlement.hls_key_uri,\n                    },\n                ];\n            }\n        }\n        entitlements.push(entitlementConfig);\n    });\n\n    const subtitles = config.subtitles.map((item: any) => ({\n        src: item.url,\n        srclang: item.locale,\n        kind: 'subtitles',\n        label: item.locale_label,\n    }));\n\n    const currentTime = playParams.continueFromPreviousPosition && config.appa < config.time_marker_end ? config.appa : 0;\n\n    return {\n        entitlements: entitlements,\n        subtitles: subtitles,\n        pulseToken: config.pulse_token,\n        currentTime: currentTime,\n        continuePaused: playParams.continuePaused,\n        articleId: config.article_id,\n        assetId: config.asset_id,\n        subtitleLocale: config.user_subtitle_locale,\n        audioLocale: config.user_audio_locale,\n        localTimeDelta: isNaN(timeStamp) ? 0 : Date.now() - timeStamp,\n        aspectRatio: config.aspect_ratio.replace('x', ':'),\n    };\n}\n\nexport function toArticleMetas(metas: any) {\n    return metas.reduce(\n        (metaObj: any, item: any) => ({\n            ...metaObj,\n            [item.key]: item.value,\n        }),\n        {}\n    );\n}\n\nexport function toArticle(article: any): Article {\n    return {\n        name: article.name,\n        metas: toArticleMetas(article.metas),\n        posters: article.posters.map(toFile),\n        images: article.images.map(toFile),\n    } as Article;\n}\n\nexport function toFile(file: any): FileData {\n    return {\n        type: file.type,\n        url: file.url,\n        baseUrl: file.base_url,\n        fileName: file.file_name,\n    } as FileData;\n}\n\nexport function getMetaValue(metas: any, key: string) {\n    return metas[key] ? metas[key] : '';\n}\n\nexport function getResizedUrl(fileData: FileData, size: {width: number; height: number}): string {\n    if (fileData) {\n        const {width, height} = size;\n        return `${fileData.baseUrl}/${width}x${height}/${fileData.fileName}`;\n    }\n    return '';\n}\n\nexport function getArticleTitle(article: Article) {\n    return getMetaValue(article.metas, 'title') || article.name;\n}\n\nexport function getArticleBackgroundImage(article: Article): FileData {\n    if (article.posters.length > 0) {\n        return article.posters[0];\n    }\n    if (this.article.length > 0) {\n        return article.images[0];\n    }\n    return null;\n}\n\nexport function toPlayConfigError(code: number): ArticlePlayErrors {\n    switch (code) {\n        case 0:\n            return ArticlePlayErrors.offlineError;\n        case 401:\n            return ArticlePlayErrors.notAuthenticated;\n        case 402:\n            return ArticlePlayErrors.needEntitlement;\n        case 403:\n            return ArticlePlayErrors.notAuthenticated;\n        case 404:\n            return ArticlePlayErrors.noPlayableAsset;\n        case 429:\n            return ArticlePlayErrors.maxConcurrentStreamNumberError;\n\n        default:\n            return ArticlePlayErrors.serverError;\n    }\n}\n\nexport function toMimeType(mimeType: string): MimeType {\n    switch (mimeType) {\n        case MimeTypeHls:\n        case MimeTypeDash:\n        case MimeTypeMp4:\n            return mimeType;\n        case 'application/vnd.apple.mpegurl': // convert legacy HLS mime-type\n            return MimeTypeHls;\n        default:\n            console.warn(`Unknown mime-type ${mimeType}, defaulting to mp4`);\n            return MimeTypeMp4;\n    }\n}\n","import {graphRequest} from './graph-request';\nimport {articleAssetPlayMutation, articleQuery} from './queries';\nimport {toArticle, toPlayConfig} from './converters';\nimport {DeviceModelContextEnum, PlayParams} from '../models/play-params';\n\nexport class ApiService {\n    private apiFetchUrl: string;\n    private token: string;\n\n    constructor(baseUrl: string, projectId: number) {\n        this.apiFetchUrl = `${baseUrl}/graphql/${projectId}`;\n        this.token = null;\n    }\n\n    setToken(token: string) {\n        this.token = token;\n    }\n\n    getArticle(articleId: number) {\n        return graphRequest(this.apiFetchUrl, articleQuery, {articleId}, this.token).then((response: any) => {\n            if (!response || !response.data || response.errors) {\n                const {message, code} = response.errors[0];\n                throw {message, code};\n            }\n            return toArticle(response.data.Article);\n        });\n    }\n\n    getArticleAssetPlayConfig(playParams: PlayParams, deviceModelContext: DeviceModelContextEnum = null) {\n        return graphRequest(\n            this.apiFetchUrl,\n            articleAssetPlayMutation,\n            {\n                articleId: playParams.articleId,\n                assetId: playParams.assetId,\n                protocols: ['dash', 'hls'],\n                device_model_context: deviceModelContext,\n            },\n            this.token\n        ).then((response: any) => {\n            if (!response || !response.data || response.errors) {\n                const {message, code} = response.errors[0];\n                throw {message, code};\n            }\n\n            return toPlayConfig(response.data.ArticleAssetPlay, playParams);\n        });\n    }\n}\n","export const articleAssetPlayMutation = `\n    mutation ArticleAssetPlay($articleId: Int, $assetId: Int, $protocols: [ArticlePlayProtocolEnum]) {\n        ArticleAssetPlay(article_id: $articleId, asset_id: $assetId, protocols: $protocols) {\n            article_id\n            asset_id\n            entitlements {\n                mime_type\n                protocol\n                manifest\n                is_live\n                token\n                encryption_type\n                key_delivery_url\n                encryption_provider\n                hls_key_uri\n                media_provider\n            }\n            subtitles {\n                url\n                locale\n                locale_label\n            }\n            pulse_token\n            appa\n            appr\n            fairplay_certificate_url\n            user_subtitle_locale\n            user_audio_locale\n            aspect_ratio\n            issued_at\n            time_marker_end\n        }\n    }\n`;\n\nexport const articleQuery = `\n    query Article($articleId: Int!) {\n        Article(id: $articleId) {\n            id\n            name\n            metas {\n                key\n                value\n            }\n            assets {\n                id\n                duration\n                linked_type\n                accessibility\n            }\n            posters {\n                type\n                url\n                title\n                base_url\n                file_name\n            }\n            images {\n                type\n                url\n                title\n                base_url\n                file_name\n            }\n        }\n    }\n`;\n","export interface PlaySession {\n    eventStack: PlayerEventState[];\n    localTimeDelta: number;\n    pulseToken: string;\n    deviceType: PlayerDeviceTypes;\n    isLive: boolean;\n    onStopCallback?: (appr: number) => void;\n}\n\nexport enum PlayingState {\n    loading, // chromecast only\n    playing,\n    paused,\n    idle,\n    buffering, // chromecast only\n    error,\n}\n\nexport interface PlayerProperties {\n    state: PlayingState;\n    error: string | null;\n    mediaDuration: number;\n    playPosition: number;\n    audioTrack: string;\n    textTrack: string;\n    resolution: string;\n}\n\nexport interface PlayerEventState extends PlayerProperties {\n    eventType: PlayerEventTypes;\n    timeStamp: number;\n}\n\nexport class PlayerLogPayload {\n    pulse_token: string;\n    event_stack: PlayerEventPayload[];\n    device_type: PlayerDeviceTypes;\n    pulse_mode: PulseMode;\n}\n\nexport interface PlayerEventPayload {\n    timestamp: number;\n    event_type: PlayerEventTypePayloads;\n    appa?: number;\n    appr?: number;\n    time_delta?: number;\n    subtitle_locale?: string;\n    audio_locale?: string;\n    event_payload?: string;\n    resolution_tag?: string;\n}\n\n// generic abstraction of player events that are taken from the video player, Chromecast and mobile implementations\nexport enum PlayerEventTypes {\n    playStart = 'playStart', // before attempt to play with given play configuration\n    playing = 'playing', // play state is playing\n    pause = 'pause', // play state is paused\n    error = 'error', // an error occured\n    stopped = 'stopped', // player was manually closed, or video was ended\n    timeupdate = 'timeupdate', // play position of video updated\n    textTrackChanged = 'textTrackChanged',\n    audioTrackChanged = 'audioTrackChanged',\n}\n\nexport enum PlayerDeviceTypes {\n    chromecast = 'chromecast',\n    default = '', // API should figure it out based on Navigator agent\n}\n\nexport enum PlayerEventTypePayloads {\n    play = 'play',\n    playing = 'playing',\n    paused = 'paused',\n    stop = 'stop',\n    error = 'error',\n    configure = 'configure',\n}\n\nexport enum PulseMode {\n    live = 'live',\n    archive = 'archive',\n    offline = 'offline',\n}\n","import {PlayerOptions} from './player-options';\n\nexport interface InitParams {\n    selector: string | HTMLElement;\n    options: PlayerOptions;\n    fullscreen?: boolean;\n    chromecastButton?: boolean;\n    defaultSkinClass?: string;\n    skipButtons?: {forward: number; backward: number} | false;\n}\n\nexport interface PlayParams {\n    articleId: number;\n    assetId: number;\n    token: string;\n    continueFromPreviousPosition: boolean;\n    continuePaused?: boolean;\n}\n\nexport enum DeviceModelContextEnum {\n    chromecast_legacy = 'chromecast_legacy',\n    chromecast_4k = 'chromecast_4k',\n    lg_legacy = 'lg_legacy',\n    lg_webos = 'lg_webos',\n    samsung_tizen = 'samsung_tizen',\n    tpvision_tva = 'tpvision_tva',\n}\n","import {\n    PlayerEventPayload,\n    PlayerEventState,\n    PlayerEventTypePayloads,\n    PlayerEventTypes,\n    PlayerLogPayload,\n    PlayingState,\n    PlaySession,\n    PulseMode,\n} from '../models/player';\n\nconst MAX_EVENTS = 30;\n\nexport class PlayerLogProcessor {\n    protected apiUrl: string;\n    protected playLogs: PlayerLogPayload[] = [];\n    protected apiCallInProgress = false;\n    protected intervalHandle: any = null;\n\n    constructor(baseUrl: string, projectId: number) {\n        this.apiUrl = `${baseUrl}/service/${projectId}/analytics/stream/pulse/log`.replace(/\\/*$/, '');\n    }\n\n    init() {\n        if (this.intervalHandle === null) {\n            this.intervalHandle = setInterval(() => {\n                this.processFirstPlayLog();\n            }, 3000);\n        }\n    }\n\n    destroy() {\n        if (this.intervalHandle) {\n            clearInterval(this.intervalHandle);\n        }\n        this.intervalHandle = null;\n    }\n\n    processPlaySession(playSession: PlaySession, timeStamp: number) {\n        if (!playSession) {\n            return;\n        }\n\n        const eventStack = playSession.eventStack;\n\n        if (eventStack.length === 0) {\n            return;\n        }\n\n        const eventStackPayload: PlayerEventPayload[] = [];\n        let i = 0,\n            sumDelta = 0,\n            lastEventWasProcessed = false;\n\n        while (i < eventStack.length) {\n            const currentEvent = eventStack[i];\n\n            if (this.isEventTypeWithoutTimeDelta(currentEvent.eventType)) {\n                // directly process these events. they have no sumDelta and do not affect the play state\n                eventStackPayload.push(this.convertEventToEventPayload(currentEvent));\n                lastEventWasProcessed = true;\n            } else {\n                lastEventWasProcessed = false;\n                if (i - 1 >= 0) {\n                    const previousEvent = eventStack[i - 1];\n\n                    sumDelta += currentEvent.timeStamp - previousEvent.timeStamp;\n\n                    if (currentEvent.state !== previousEvent.state) {\n                        eventStackPayload.push(this.createDeltaEventPayload(previousEvent, previousEvent.timeStamp, sumDelta));\n                        sumDelta = 0;\n                    }\n                }\n            }\n            i++;\n        }\n\n        const lastEvent = eventStack[eventStack.length - 1];\n\n        if (sumDelta > 0 || !lastEventWasProcessed) {\n            eventStackPayload.push(this.createDeltaEventPayload(lastEvent, timeStamp, sumDelta));\n        }\n\n        if (eventStackPayload.length > 0) {\n            if (eventStackPayload.length > MAX_EVENTS) {\n                // if event stack too big, add error with runaway info and slice nr of items\n                const lastLogEvent = eventStackPayload[eventStackPayload.length - 1];\n                eventStackPayload.splice(MAX_EVENTS - 1);\n                lastLogEvent.event_type = PlayerEventTypePayloads.error;\n                lastLogEvent.event_payload = '{\"code\": 429, \"message\": \"Too many events\"}'; // runaway\n                eventStackPayload.push(lastLogEvent);\n            }\n\n            // check if there is already a log for this session\n            let playLogPayload = this.getPlayerLogPayloadWithPulseToken(playSession.pulseToken);\n            if (!playLogPayload) {\n                playLogPayload = {\n                    event_stack: [],\n                    pulse_token: playSession.pulseToken,\n                    pulse_mode: playSession.isLive ? PulseMode.live : PulseMode.offline,\n                    device_type: playSession.deviceType,\n                };\n                this.playLogs.push(playLogPayload);\n            }\n            // keep the event_stack pointer in tact by using push\n            eventStackPayload.forEach(e => playLogPayload.event_stack.push(e));\n\n            this.processPlayLog(playLogPayload, playSession);\n        }\n    }\n\n    processFirstPlayLog() {\n        if (this.playLogs.length > 0) {\n            this.processPlayLog(this.playLogs[0], null);\n        }\n    }\n\n    protected processPlayLog(currentLog: PlayerLogPayload, playSession: PlaySession) {\n        if (!currentLog || this.apiCallInProgress) {\n            return;\n        }\n\n        if (currentLog.event_stack.length === 0) {\n            this.removePlayLog(currentLog);\n            return;\n        }\n\n        const logToSend: PlayerLogPayload = {\n            ...currentLog,\n            event_stack: [],\n        };\n\n        let eventStackIndex = 0,\n            isStopCutOff = false;\n\n        while (eventStackIndex < currentLog.event_stack.length && logToSend.event_stack.length < MAX_EVENTS && !isStopCutOff) {\n            const currentEvent = currentLog.event_stack[eventStackIndex];\n            eventStackIndex++;\n            logToSend.event_stack.push(currentEvent);\n\n            if (currentEvent.event_type === PlayerEventTypePayloads.stop) {\n                isStopCutOff = true;\n            }\n        }\n\n        // for offline logging, always accumulate until MAX_EVENTS before sending unless it's a stop cut off.\n        if (logToSend.pulse_mode === PulseMode.offline && logToSend.event_stack.length < MAX_EVENTS && !isStopCutOff) {\n            return;\n        }\n\n        // transaction start\n        this.apiCallInProgress = true;\n\n        return fetch(this.apiUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Accept: 'application/json',\n            },\n            body: JSON.stringify(logToSend),\n        })\n            .then(() => {\n                return true;\n            })\n            .catch(error => {\n                return error.status !== 0;\n            })\n            .then(response => {\n                if (response) {\n                    currentLog.event_stack.splice(0, eventStackIndex);\n                    if (currentLog.event_stack.length === 0) {\n                        this.removePlayLog(currentLog);\n                    }\n                } else {\n                    currentLog.pulse_mode = PulseMode.archive;\n                }\n                this.apiCallInProgress = false;\n            });\n    }\n\n    protected getPlayerLogPayloadWithPulseToken(pulseToken: string): PlayerLogPayload {\n        return this.playLogs.find(log => log.pulse_token === pulseToken);\n    }\n\n    protected removePlayLog(logPayload: PlayerLogPayload) {\n        const index = this.playLogs.findIndex(log => log.pulse_token === logPayload.pulse_token);\n        if (index >= 0) {\n            this.playLogs.splice(index, 1);\n        }\n    }\n\n    protected isEventTypeWithoutTimeDelta(eventType: PlayerEventTypes) {\n        return [PlayerEventTypes.textTrackChanged, PlayerEventTypes.audioTrackChanged, PlayerEventTypes.playStart].indexOf(eventType) >= 0;\n    }\n\n    protected createBaseEventPayload(playerEvent: PlayerEventState, eventType: PlayerEventTypePayloads): PlayerEventPayload {\n        return {\n            timestamp: playerEvent.timeStamp,\n            event_type: eventType,\n            appa: playerEvent.playPosition,\n            appr: Math.min(playerEvent.playPosition / playerEvent.mediaDuration, 1),\n            resolution_tag: playerEvent.resolution,\n        };\n    }\n\n    protected convertEventToEventPayload(playerEvent: PlayerEventState): PlayerEventPayload {\n        if (playerEvent.eventType === PlayerEventTypes.playStart) {\n            return {\n                timestamp: playerEvent.timeStamp,\n                event_type: PlayerEventTypePayloads.play,\n            };\n        }\n        const eventType = this.convertEventTypeToEventTypePayload(playerEvent);\n        const baseEvent = this.createBaseEventPayload(playerEvent, eventType);\n        switch (playerEvent.eventType) {\n            case PlayerEventTypes.audioTrackChanged:\n                return {\n                    ...baseEvent,\n                    audio_locale: playerEvent.audioTrack,\n                };\n            case PlayerEventTypes.textTrackChanged:\n                return {\n                    ...baseEvent,\n                    subtitle_locale: playerEvent.textTrack,\n                };\n            default:\n                return baseEvent;\n        }\n    }\n\n    protected createDeltaEventPayload(playerEvent: PlayerEventState, timestamp: number, timeDelta: number): PlayerEventPayload {\n        const eventType = this.getEventTypePayloadFromEventState(playerEvent);\n        const baseEvent = this.createBaseEventPayload(playerEvent, eventType);\n        const errorPart = playerEvent.state === PlayingState.error ? {event_payload: playerEvent.error} : {};\n\n        return {\n            ...baseEvent,\n            ...errorPart,\n            timestamp,\n            time_delta: timeDelta / 1000,\n        };\n    }\n\n    protected getEventTypePayloadFromEventState(playerEvent: PlayerEventState): PlayerEventTypePayloads {\n        switch (playerEvent.state) {\n            case PlayingState.playing:\n                return PlayerEventTypePayloads.playing;\n            case PlayingState.paused:\n                return PlayerEventTypePayloads.paused;\n            case PlayingState.error:\n                return PlayerEventTypePayloads.error;\n            case PlayingState.buffering:\n            case PlayingState.loading:\n                return PlayerEventTypePayloads.paused; // buffering and loading converted to paused for API\n            case PlayingState.idle:\n                return PlayerEventTypePayloads.stop;\n        }\n    }\n\n    protected convertEventTypeToEventTypePayload(playerEvent: PlayerEventState): PlayerEventTypePayloads {\n        switch (playerEvent.eventType) {\n            case PlayerEventTypes.playStart:\n                return PlayerEventTypePayloads.play;\n            case PlayerEventTypes.audioTrackChanged:\n            case PlayerEventTypes.textTrackChanged:\n                return PlayerEventTypePayloads.configure;\n\n            // because e.g. `timeupdate` events can happen while paused / playing, base the rest on state.\n            default: {\n                this.getEventTypePayloadFromEventState(playerEvent);\n            }\n        }\n    }\n}\n","import {PlayerLogProcessor} from './player-log-processor';\nimport {PlayerDeviceTypes, PlayerEventTypes, PlayerProperties, PlayingState, PlaySession} from '../models/player';\n\nexport class PlayerLoggerService {\n    private playerLogProcessor: PlayerLogProcessor;\n    protected playerProperties: PlayerProperties;\n    protected playSession: PlaySession;\n    protected intervalHandle = 0;\n\n    constructor(baseUrl: string, projectId: number) {\n        this.playerLogProcessor = new PlayerLogProcessor(baseUrl, projectId);\n        this.reset();\n    }\n\n    init() {\n        this.playerLogProcessor.init();\n    }\n\n    destroy() {\n        this.playerLogProcessor.destroy();\n    }\n\n    onStart(\n        pulseToken: string,\n        deviceType: PlayerDeviceTypes,\n        localTimeDelta: number,\n        isLive: boolean,\n        onStopCallback?: (appr: number) => void\n    ) {\n        this.reset();\n\n        this.playSession = {\n            pulseToken,\n            deviceType,\n            eventStack: [],\n            localTimeDelta,\n            isLive,\n            onStopCallback,\n        };\n    }\n\n    onCurrentTimeUpdated(currentTime: number) {\n        this.playerProperties.playPosition = currentTime;\n\n        if (this.playerProperties.mediaDuration > 0 && this.playerProperties.state !== PlayingState.idle) {\n            this.logEvent(PlayerEventTypes.timeupdate);\n        }\n    }\n\n    onDurationUpdated(duration: number) {\n        this.playerProperties.mediaDuration = duration;\n    }\n\n    onPlaying() {\n        if (this.playerProperties.state !== PlayingState.playing) {\n            if (this.playerProperties.state === PlayingState.idle) {\n                this.playerProperties.state = PlayingState.playing;\n                this.logEvent(PlayerEventTypes.playStart);\n                this.processPlaySession();\n                this.startInterval();\n            } else {\n                this.playerProperties.state = PlayingState.playing;\n                this.logEvent(PlayerEventTypes.playing);\n            }\n        }\n    }\n\n    onPause() {\n        if (this.playerProperties.state !== PlayingState.paused && this.playerProperties.state !== PlayingState.idle) {\n            this.playerProperties.state = PlayingState.paused;\n            this.logEvent(PlayerEventTypes.pause);\n        }\n    }\n\n    onError(error: string) {\n        if (this.playerProperties.state !== PlayingState.error) {\n            this.playerProperties.state = PlayingState.error;\n            this.playerProperties.error = error;\n            this.logEvent(PlayerEventTypes.error);\n        }\n    }\n\n    onStop() {\n        if (this.playerProperties.state !== PlayingState.idle) {\n            this.playerProperties.state = PlayingState.idle;\n            this.logEvent(PlayerEventTypes.stopped);\n            this.stopInterval();\n            this.processPlaySession();\n        }\n    }\n\n    onTextTrackChanged(textTrack: string) {\n        if (this.playerProperties.state === PlayingState.idle) {\n            return;\n        }\n        this.playerProperties.textTrack = textTrack;\n        this.logEvent(PlayerEventTypes.textTrackChanged);\n    }\n\n    onAudioTrackChanged(audioTrack: string) {\n        if (this.playerProperties.state === PlayingState.idle) {\n            return;\n        }\n        this.playerProperties.audioTrack = audioTrack;\n\n        this.logEvent(PlayerEventTypes.audioTrackChanged);\n    }\n\n    updateProperties(playerProperties: Partial<PlayerProperties>) {\n        this.playerProperties = {\n            ...this.playerProperties,\n            ...playerProperties,\n        };\n    }\n\n    protected startInterval() {\n        this.stopInterval();\n        // @ts-ignore\n        this.intervalHandle = setInterval(() => {\n            this.processPlaySession();\n        }, 30000);\n    }\n\n    protected stopInterval() {\n        if (this.intervalHandle) {\n            clearInterval(this.intervalHandle);\n        }\n    }\n\n    protected processPlaySession() {\n        this.playerLogProcessor.processPlaySession({...this.playSession}, this.getTimeStamp());\n        this.playSession.eventStack = [];\n    }\n\n    protected logEvent(eventType: PlayerEventTypes) {\n        if (this.playSession) {\n            this.playSession.eventStack.push({\n                ...this.playerProperties,\n                eventType,\n                timeStamp: this.getTimeStamp(),\n            });\n        }\n    }\n\n    protected reset() {\n        this.playSession = null;\n\n        this.playerProperties = {\n            state: PlayingState.idle,\n            error: null,\n            mediaDuration: 0,\n            playPosition: 0,\n            audioTrack: null,\n            textTrack: null,\n            resolution: null,\n        };\n    }\n\n    protected getTimeStamp() {\n        return Date.now() - (this.playSession ? this.playSession.localTimeDelta : 0);\n    }\n}\n"],"names":["ArticlePlayErrors","__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","graphRequest","apiFetchUrl","query","variables","token","fetch","method","headers","Accept","Authorization","body","JSON","stringify","then","response","json","MimeTypeHls","MimeTypeMp4","toFile","file","type","url","baseUrl","base_url","fileName","file_name","toMimeType","mimeType","console","warn","ApiService","constructor","projectId","this","setToken","getArticle","articleId","data","errors","message","code","name","article","Article","metas","reduce","metaObj","item","value","posters","map","images","getArticleAssetPlayConfig","playParams","deviceModelContext","assetId","protocols","device_model_context","config","timeStamp","Date","parse","issued_at","entitlements","find","entitlement","encryption_type","filter","forEach","entitlementConfig","src","manifest","mime_type","isLive","is_live","protectionInfo","mediaProvider","media_provider","protocol","indexOf","authenticationToken","encryption_provider","keyDeliveryUrl","key_delivery_url","encryptionProvider","certificateUrl","fairplay_certificate_url","contentKeyId","replace","hls_key_uri","push","subtitles","srclang","locale","kind","label","locale_label","currentTime","continueFromPreviousPosition","appa","time_marker_end","pulseToken","pulse_token","continuePaused","article_id","asset_id","subtitleLocale","user_subtitle_locale","audioLocale","user_audio_locale","localTimeDelta","isNaN","now","aspectRatio","aspect_ratio","toPlayConfig","ArticleAssetPlay","PlayingState","PlayerEventTypes","PlayerDeviceTypes","PlayerEventTypePayloads","PulseMode","DeviceModelContextEnum","PlayerLogProcessor","playLogs","apiCallInProgress","intervalHandle","apiUrl","init","setInterval","processFirstPlayLog","destroy","clearInterval","processPlaySession","playSession","eventStack","length","eventStackPayload","i","sumDelta","lastEventWasProcessed","currentEvent","isEventTypeWithoutTimeDelta","eventType","convertEventToEventPayload","previousEvent","state","createDeltaEventPayload","lastEvent","lastLogEvent","splice","MAX_EVENTS","event_type","error","event_payload","playLogPayload","getPlayerLogPayloadWithPulseToken","event_stack","pulse_mode","live","offline","device_type","deviceType","e","processPlayLog","currentLog","removePlayLog","logToSend","eventStackIndex","isStopCutOff","stop","catch","status","archive","log","logPayload","index","findIndex","textTrackChanged","audioTrackChanged","playStart","createBaseEventPayload","playerEvent","timestamp","playPosition","appr","Math","min","mediaDuration","resolution_tag","resolution","play","convertEventTypeToEventTypePayload","baseEvent","audio_locale","audioTrack","subtitle_locale","textTrack","timeDelta","getEventTypePayloadFromEventState","time_delta","playing","paused","buffering","loading","idle","configure","PlayerLoggerService","playerLogProcessor","reset","onStart","onStopCallback","onCurrentTimeUpdated","playerProperties","logEvent","timeupdate","onDurationUpdated","duration","onPlaying","startInterval","onPause","pause","onError","onStop","stopped","stopInterval","onTextTrackChanged","onAudioTrackChanged","updateProperties","getTimeStamp"],"sourceRoot":""}