{"version":3,"file":"logging.js","mappings":"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","sources":["webpack://audienceplayer-embed-player/webpack/bootstrap","webpack://audienceplayer-embed-player/./src/models/play-config.ts","webpack://audienceplayer-embed-player/webpack/runtime/define property getters","webpack://audienceplayer-embed-player/webpack/runtime/hasOwnProperty shorthand","webpack://audienceplayer-embed-player/./src/api/graph-request.ts","webpack://audienceplayer-embed-player/./src/api/converters.ts","webpack://audienceplayer-embed-player/./src/api/api-service.ts","webpack://audienceplayer-embed-player/./src/api/queries.ts","webpack://audienceplayer-embed-player/./src/models/player.ts","webpack://audienceplayer-embed-player/./src/logging/player-log-processor.ts","webpack://audienceplayer-embed-player/./src/logging/player-logger-service.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","export interface PlayConfig {\n    pulseToken: string;\n    currentTime: number;\n    entitlements: PlayEntitlement[];\n    subtitles: PlayConfigSubtitle[];\n    articleId?: number;\n    assetId: number;\n    subtitleLocale: string;\n    audioLocale: string;\n    aspectRatio: string;\n    localTimeDelta?: number;\n    skipIntro?: {\n        start: number;\n        end: number;\n        label: string;\n    };\n}\n\nexport interface PlayEntitlement {\n    src: string;\n    type: MimeType;\n    isLive: boolean;\n    protectionInfo: PlayConfigProtection[] | null;\n    mediaProvider: string;\n}\n\nexport interface PlayConfigSubtitle {\n    src: string;\n    srclang: string;\n    kind: string;\n    label: string;\n}\n\nexport interface PlayConfigProtection {\n    type: DrmType;\n    authenticationToken?: string;\n    certificateUrl?: string;\n    keyDeliveryUrl: string;\n    encryptionProvider: string;\n    contentKeyId?: string;\n}\n\nexport enum ArticlePlayErrors {\n    noPlayableAsset = 'noPlayableAsset',\n    notAuthenticated = 'notAuthenticated',\n    needEntitlement = 'needEntitlement',\n    serverError = 'serverError',\n    offlineError = 'offlineError',\n    maxConcurrentStreamNumberError = 'maxConcurrentStreamNumberError',\n}\n\nexport type DrmType = 'Widevine' | 'PlayReady' | 'FairPlay';\nexport type MimeType = 'application/x-mpegURL' | 'application/dash+xml' | 'video/mp4';\nexport const MimeTypeHls = 'application/x-mpegURL';\nexport const MimeTypeDash = 'application/dash+xml';\nexport const MimeTypeMp4 = 'video/mp4';\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function graphRequest(apiFetchUrl: string, query: string, variables: any, token: string) {\n    const authHeader = token ? {Authorization: 'Bearer ' + token} : {};\n\n    return fetch(apiFetchUrl, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            Accept: 'application/json',\n            ...authHeader,\n        },\n        body: JSON.stringify({\n            query,\n            variables,\n        }),\n    }).then(response => response.json());\n}\n","import {PlayConfig, PlayEntitlement, ArticlePlayErrors, MimeType, MimeTypeHls, MimeTypeDash, MimeTypeMp4} from '../models/play-config';\nimport {Article} from '../models/article';\nimport {FileData} from '../models/file-data';\n\nexport function toPlayConfig(config: any, continueFromPreviousPosition: boolean): PlayConfig {\n    const timeStamp = Date.parse(config.issued_at);\n    const entitlements: PlayEntitlement[] = [];\n\n    // check if the entitlements contain FPS in order to know when to filter out aes\n    const filterAES = !!config.entitlements.find((entitlement: any) => entitlement.encryption_type === 'fps');\n    const configEntitlements = filterAES\n        ? config.entitlements.filter((entitlement: any) => {\n              return entitlement.encryption_type !== 'aes';\n          })\n        : config.entitlements;\n\n    configEntitlements.forEach((entitlement: any) => {\n        const entitlementConfig: PlayEntitlement = {\n            src: entitlement.manifest,\n            type: toMimeType(entitlement.mime_type),\n            isLive: entitlement.is_live,\n            protectionInfo: null,\n            mediaProvider: entitlement.media_provider,\n        };\n\n        if (entitlement.encryption_type) {\n            if (entitlement.encryption_type === 'cenc' && entitlement.protocol.indexOf('dash') === 0) {\n                entitlementConfig.protectionInfo = [\n                    {\n                        type: 'Widevine',\n                        authenticationToken:\n                            entitlement.encryption_provider === 'azl' && !!entitlement.token ? 'Bearer ' + entitlement.token : '',\n                        keyDeliveryUrl: entitlement.key_delivery_url,\n                        encryptionProvider: entitlement.encryption_provider,\n                    },\n                ];\n            } else if (entitlement.encryption_type === 'fps' && entitlement.protocol.indexOf('hls') === 0) {\n                entitlementConfig.protectionInfo = [\n                    {\n                        type: 'FairPlay',\n                        authenticationToken:\n                            entitlement.encryption_provider === 'azl' && !!entitlement.token ? 'Bearer ' + entitlement.token : '',\n                        certificateUrl: config.fairplay_certificate_url,\n                        keyDeliveryUrl: entitlement.key_delivery_url,\n                        encryptionProvider: entitlement.encryption_provider,\n                        contentKeyId:\n                            entitlement.encryption_provider === 'azl'\n                                ? entitlement.key_delivery_url.replace('https://', 'skd://')\n                                : entitlement.hls_key_uri,\n                    },\n                ];\n            }\n        }\n        entitlements.push(entitlementConfig);\n    });\n\n    const subtitles = config.subtitles.map((item: any) => ({\n        src: item.url,\n        srclang: item.locale,\n        kind: 'subtitles',\n        label: item.locale_label,\n    }));\n\n    const currentTime = continueFromPreviousPosition && config.appa < config.time_marker_end ? config.appa : 0;\n\n    return {\n        entitlements: entitlements,\n        subtitles: subtitles,\n        pulseToken: config.pulse_token,\n        currentTime: currentTime,\n        articleId: config.article_id,\n        assetId: config.asset_id,\n        subtitleLocale: config.user_subtitle_locale,\n        audioLocale: config.user_audio_locale,\n        localTimeDelta: isNaN(timeStamp) ? 0 : Date.now() - timeStamp,\n        aspectRatio: config.aspect_ratio.replace('x', ':'),\n    };\n}\n\nexport function toArticleMetas(metas: any) {\n    return metas.reduce(\n        (metaObj: any, item: any) => ({\n            ...metaObj,\n            [item.key]: item.value,\n        }),\n        {}\n    );\n}\n\nexport function toArticle(article: any): Article {\n    return {\n        name: article.name,\n        metas: toArticleMetas(article.metas),\n        posters: article.posters.map(toFile),\n        images: article.images.map(toFile),\n    } as Article;\n}\n\nexport function toFile(file: any): FileData {\n    return {\n        type: file.type,\n        url: file.url,\n        baseUrl: file.base_url,\n        fileName: file.file_name,\n    } as FileData;\n}\n\nexport function getMetaValue(metas: any, key: string) {\n    return metas[key] ? metas[key] : '';\n}\n\nexport function getResizedUrl(fileData: FileData, size: {width: number; height: number}): string {\n    if (fileData) {\n        const {width, height} = size;\n        return `${fileData.baseUrl}/${width}x${height}/${fileData.fileName}`;\n    }\n    return '';\n}\n\nexport function getArticleTitle(article: Article) {\n    return getMetaValue(article.metas, 'title') || article.name;\n}\n\nexport function getArticleBackgroundImage(article: Article): FileData {\n    if (article.posters.length > 0) {\n        return article.posters[0];\n    }\n    if (this.article.length > 0) {\n        return article.images[0];\n    }\n    return null;\n}\n\nexport function toPlayConfigError(code: number): ArticlePlayErrors {\n    switch (code) {\n        case 0:\n            return ArticlePlayErrors.offlineError;\n        case 401:\n            return ArticlePlayErrors.notAuthenticated;\n        case 402:\n            return ArticlePlayErrors.needEntitlement;\n        case 403:\n            return ArticlePlayErrors.notAuthenticated;\n        case 404:\n            return ArticlePlayErrors.noPlayableAsset;\n        case 429:\n            return ArticlePlayErrors.maxConcurrentStreamNumberError;\n\n        default:\n            return ArticlePlayErrors.serverError;\n    }\n}\n\nexport function toMimeType(mimeType: string): MimeType {\n    switch (mimeType) {\n        case MimeTypeHls:\n        case MimeTypeDash:\n        case MimeTypeMp4:\n            return mimeType;\n        case 'application/vnd.apple.mpegurl': // convert legacy HLS mime-type\n            return MimeTypeHls;\n        default:\n            console.warn(`Unknown mime-type ${mimeType}, defaulting to mp4`);\n            return MimeTypeMp4;\n    }\n}\n","import {graphRequest} from './graph-request';\nimport {articleAssetPlayMutation, articleQuery} from './queries';\nimport {toArticle, toPlayConfig} from './converters';\n\nexport class ApiService {\n    private apiFetchUrl: string;\n    private token: string;\n\n    constructor(baseUrl: string, projectId: number) {\n        this.apiFetchUrl = `${baseUrl}/graphql/${projectId}`;\n        this.token = null;\n    }\n\n    setToken(token: string) {\n        this.token = token;\n    }\n\n    getArticleAssetPlayConfig(articleId: number, assetId: number, continueFromPreviousPosition: boolean) {\n        return graphRequest(this.apiFetchUrl, articleAssetPlayMutation, {articleId, assetId, protocols: ['dash', 'hls']}, this.token).then(\n            (response: any) => {\n                if (!response || !response.data || response.errors) {\n                    const {message, code} = response.errors[0];\n                    throw {message, code}; // @TODO to play config error\n                }\n\n                return toPlayConfig(response.data.ArticleAssetPlay, continueFromPreviousPosition);\n            }\n        );\n    }\n\n    getArticle(articleId: number) {\n        return graphRequest(this.apiFetchUrl, articleQuery, {articleId}, this.token).then((response: any) => {\n            if (!response || !response.data || response.errors) {\n                const {message, code} = response.errors[0];\n                throw {message, code};\n            }\n            return toArticle(response.data.Article);\n        });\n    }\n}\n","export const articleAssetPlayMutation = `\n    mutation ArticleAssetPlay($articleId: Int, $assetId: Int, $protocols: [ArticlePlayProtocolEnum]) {\n        ArticleAssetPlay(article_id: $articleId, asset_id: $assetId, protocols: $protocols) {\n            article_id\n            asset_id\n            entitlements {\n                mime_type\n                protocol\n                manifest\n                is_live\n                token\n                encryption_type\n                key_delivery_url\n                encryption_provider\n                hls_key_uri\n                media_provider\n            }\n            subtitles {\n                url\n                locale\n                locale_label\n            }\n            pulse_token\n            appa\n            appr\n            fairplay_certificate_url\n            user_subtitle_locale\n            user_audio_locale\n            aspect_ratio\n            issued_at\n            time_marker_end\n        }\n    }\n`;\n\nexport const articleQuery = `\n    query Article($articleId: Int!) {\n        Article(id: $articleId) {\n            id\n            name\n            metas {\n                key\n                value\n            }\n            assets {\n                id\n                duration\n                linked_type\n                accessibility\n            }\n            posters {\n                type\n                url\n                title\n                base_url\n                file_name\n            }\n            images {\n                type\n                url\n                title\n                base_url\n                file_name\n            }\n        }\n    }\n`;\n","export interface PlaySession {\n    eventStack: PlayerEventState[];\n    localTimeDelta: number;\n    pulseToken: string;\n    deviceType: PlayerDeviceTypes;\n    isLive: boolean;\n    onStopCallback?: (appr: number) => void;\n}\n\nexport enum PlayingState {\n    loading, // chromecast only\n    playing,\n    paused,\n    idle,\n    buffering, // chromecast only\n    error,\n}\n\nexport interface PlayerProperties {\n    state: PlayingState;\n    error: string | null;\n    mediaDuration: number;\n    playPosition: number;\n    audioTrack: string;\n    textTrack: string;\n    resolution: string;\n}\n\nexport interface PlayerEventState extends PlayerProperties {\n    eventType: PlayerEventTypes;\n    timeStamp: number;\n}\n\nexport class PlayerLogPayload {\n    pulse_token: string;\n    event_stack: PlayerEventPayload[];\n    device_type: PlayerDeviceTypes;\n    pulse_mode: PulseMode;\n}\n\nexport interface PlayerEventPayload {\n    timestamp: number;\n    event_type: PlayerEventTypePayloads;\n    appa?: number;\n    appr?: number;\n    time_delta?: number;\n    subtitle_locale?: string;\n    audio_locale?: string;\n    event_payload?: string;\n    resolution_tag?: string;\n}\n\n// generic abstraction of player events that are taken from the video player, Chromecast and mobile implementations\nexport enum PlayerEventTypes {\n    playStart = 'playStart', // before attempt to play with given play configuration\n    playing = 'playing', // play state is playing\n    pause = 'pause', // play state is paused\n    error = 'error', // an error occured\n    stopped = 'stopped', // player was manually closed, or video was ended\n    timeupdate = 'timeupdate', // play position of video updated\n    textTrackChanged = 'textTrackChanged',\n    audioTrackChanged = 'audioTrackChanged',\n}\n\nexport enum PlayerDeviceTypes {\n    chromecast = 'chromecast',\n    default = '', // API should figure it out based on Navigator agent\n}\n\nexport enum PlayerEventTypePayloads {\n    play = 'play',\n    playing = 'playing',\n    paused = 'paused',\n    stop = 'stop',\n    error = 'error',\n    configure = 'configure',\n}\n\nexport enum PulseMode {\n    live = 'live',\n    archive = 'archive',\n    offline = 'offline',\n}\n","import {\n    PlayerEventPayload,\n    PlayerEventState,\n    PlayerEventTypePayloads,\n    PlayerEventTypes,\n    PlayerLogPayload,\n    PlayingState,\n    PlaySession,\n    PulseMode,\n} from '../models/player';\n\nconst MAX_EVENTS = 30;\n\nexport class PlayerLogProcessor {\n    protected apiUrl: string;\n    protected playLogs: PlayerLogPayload[] = [];\n    protected apiCallInProgress = false;\n    protected intervalHandle: any = null;\n\n    constructor(baseUrl: string, projectId: number) {\n        this.apiUrl = `${baseUrl}/service/${projectId}/analytics/stream/pulse/log`.replace(/\\/*$/, '');\n    }\n\n    init() {\n        if (this.intervalHandle === null) {\n            this.intervalHandle = setInterval(() => {\n                this.processFirstPlayLog();\n            }, 3000);\n        }\n    }\n\n    destroy() {\n        if (this.intervalHandle) {\n            clearInterval(this.intervalHandle);\n        }\n        this.intervalHandle = null;\n    }\n\n    processPlaySession(playSession: PlaySession, timeStamp: number) {\n        if (!playSession) {\n            return;\n        }\n\n        const eventStack = playSession.eventStack;\n\n        if (eventStack.length === 0) {\n            return;\n        }\n\n        const eventStackPayload: PlayerEventPayload[] = [];\n        let i = 0,\n            sumDelta = 0,\n            lastEventWasProcessed = false;\n\n        while (i < eventStack.length) {\n            const currentEvent = eventStack[i];\n\n            if (this.isEventTypeWithoutTimeDelta(currentEvent.eventType)) {\n                // directly process these events. they have no sumDelta and do not affect the play state\n                eventStackPayload.push(this.convertEventToEventPayload(currentEvent));\n                lastEventWasProcessed = true;\n            } else {\n                lastEventWasProcessed = false;\n                if (i - 1 >= 0) {\n                    const previousEvent = eventStack[i - 1];\n\n                    sumDelta += currentEvent.timeStamp - previousEvent.timeStamp;\n\n                    if (currentEvent.state !== previousEvent.state) {\n                        eventStackPayload.push(this.createDeltaEventPayload(previousEvent, previousEvent.timeStamp, sumDelta));\n                        sumDelta = 0;\n                    }\n                }\n            }\n            i++;\n        }\n\n        const lastEvent = eventStack[eventStack.length - 1];\n\n        if (sumDelta > 0 || !lastEventWasProcessed) {\n            eventStackPayload.push(this.createDeltaEventPayload(lastEvent, timeStamp, sumDelta));\n        }\n\n        if (eventStackPayload.length > 0) {\n            if (eventStackPayload.length > MAX_EVENTS) {\n                // if event stack too big, add error with runaway info and slice nr of items\n                const lastLogEvent = eventStackPayload[eventStackPayload.length - 1];\n                eventStackPayload.splice(MAX_EVENTS - 1);\n                lastLogEvent.event_type = PlayerEventTypePayloads.error;\n                lastLogEvent.event_payload = '{\"code\": 429, \"message\": \"Too many events\"}'; // runaway\n                eventStackPayload.push(lastLogEvent);\n            }\n\n            // check if there is already a log for this session\n            let playLogPayload = this.getPlayerLogPayloadWithPulseToken(playSession.pulseToken);\n            if (!playLogPayload) {\n                playLogPayload = {\n                    event_stack: [],\n                    pulse_token: playSession.pulseToken,\n                    pulse_mode: playSession.isLive ? PulseMode.live : PulseMode.offline,\n                    device_type: playSession.deviceType,\n                };\n                this.playLogs.push(playLogPayload);\n            }\n            // keep the event_stack pointer in tact by using push\n            eventStackPayload.forEach(e => playLogPayload.event_stack.push(e));\n\n            this.processPlayLog(playLogPayload, playSession);\n        }\n    }\n\n    processFirstPlayLog() {\n        if (this.playLogs.length > 0) {\n            this.processPlayLog(this.playLogs[0], null);\n        }\n    }\n\n    protected processPlayLog(currentLog: PlayerLogPayload, playSession: PlaySession) {\n        if (!currentLog || this.apiCallInProgress) {\n            return;\n        }\n\n        if (currentLog.event_stack.length === 0) {\n            this.removePlayLog(currentLog);\n            return;\n        }\n\n        const logToSend: PlayerLogPayload = {\n            ...currentLog,\n            event_stack: [],\n        };\n\n        let eventStackIndex = 0,\n            isStopCutOff = false;\n\n        while (eventStackIndex < currentLog.event_stack.length && logToSend.event_stack.length < MAX_EVENTS && !isStopCutOff) {\n            const currentEvent = currentLog.event_stack[eventStackIndex];\n            eventStackIndex++;\n            logToSend.event_stack.push(currentEvent);\n\n            if (currentEvent.event_type === PlayerEventTypePayloads.stop) {\n                isStopCutOff = true;\n            }\n        }\n\n        // for offline logging, always accumulate until MAX_EVENTS before sending unless it's a stop cut off.\n        if (logToSend.pulse_mode === PulseMode.offline && logToSend.event_stack.length < MAX_EVENTS && !isStopCutOff) {\n            return;\n        }\n\n        // transaction start\n        this.apiCallInProgress = true;\n\n        return fetch(this.apiUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Accept: 'application/json',\n            },\n            body: JSON.stringify(logToSend),\n        })\n            .then(() => {\n                return true;\n            })\n            .catch(error => {\n                return error.status !== 0;\n            })\n            .then(response => {\n                if (response) {\n                    currentLog.event_stack.splice(0, eventStackIndex);\n                    if (currentLog.event_stack.length === 0) {\n                        this.removePlayLog(currentLog);\n                    }\n                } else {\n                    currentLog.pulse_mode = PulseMode.archive;\n                }\n                this.apiCallInProgress = false;\n            });\n    }\n\n    protected getPlayerLogPayloadWithPulseToken(pulseToken: string): PlayerLogPayload {\n        return this.playLogs.find(log => log.pulse_token === pulseToken);\n    }\n\n    protected removePlayLog(logPayload: PlayerLogPayload) {\n        const index = this.playLogs.findIndex(log => log.pulse_token === logPayload.pulse_token);\n        if (index >= 0) {\n            this.playLogs.splice(index, 1);\n        }\n    }\n\n    protected isEventTypeWithoutTimeDelta(eventType: PlayerEventTypes) {\n        return [PlayerEventTypes.textTrackChanged, PlayerEventTypes.audioTrackChanged, PlayerEventTypes.playStart].indexOf(eventType) >= 0;\n    }\n\n    protected createBaseEventPayload(playerEvent: PlayerEventState, eventType: PlayerEventTypePayloads): PlayerEventPayload {\n        return {\n            timestamp: playerEvent.timeStamp,\n            event_type: eventType,\n            appa: playerEvent.playPosition,\n            appr: Math.min(playerEvent.playPosition / playerEvent.mediaDuration, 1),\n            resolution_tag: playerEvent.resolution,\n        };\n    }\n\n    protected convertEventToEventPayload(playerEvent: PlayerEventState): PlayerEventPayload {\n        if (playerEvent.eventType === PlayerEventTypes.playStart) {\n            return {\n                timestamp: playerEvent.timeStamp,\n                event_type: PlayerEventTypePayloads.play,\n            };\n        }\n        const eventType = this.convertEventTypeToEventTypePayload(playerEvent);\n        const baseEvent = this.createBaseEventPayload(playerEvent, eventType);\n        switch (playerEvent.eventType) {\n            case PlayerEventTypes.audioTrackChanged:\n                return {\n                    ...baseEvent,\n                    audio_locale: playerEvent.audioTrack,\n                };\n            case PlayerEventTypes.textTrackChanged:\n                return {\n                    ...baseEvent,\n                    subtitle_locale: playerEvent.textTrack,\n                };\n            default:\n                return baseEvent;\n        }\n    }\n\n    protected createDeltaEventPayload(playerEvent: PlayerEventState, timestamp: number, timeDelta: number): PlayerEventPayload {\n        const eventType = this.getEventTypePayloadFromEventState(playerEvent);\n        const baseEvent = this.createBaseEventPayload(playerEvent, eventType);\n        const errorPart = playerEvent.state === PlayingState.error ? {event_payload: playerEvent.error} : {};\n\n        return {\n            ...baseEvent,\n            ...errorPart,\n            timestamp,\n            time_delta: timeDelta / 1000,\n        };\n    }\n\n    protected getEventTypePayloadFromEventState(playerEvent: PlayerEventState): PlayerEventTypePayloads {\n        switch (playerEvent.state) {\n            case PlayingState.playing:\n                return PlayerEventTypePayloads.playing;\n            case PlayingState.paused:\n                return PlayerEventTypePayloads.paused;\n            case PlayingState.error:\n                return PlayerEventTypePayloads.error;\n            case PlayingState.buffering:\n            case PlayingState.loading:\n                return PlayerEventTypePayloads.paused; // buffering and loading converted to paused for API\n            case PlayingState.idle:\n                return PlayerEventTypePayloads.stop;\n        }\n    }\n\n    protected convertEventTypeToEventTypePayload(playerEvent: PlayerEventState): PlayerEventTypePayloads {\n        switch (playerEvent.eventType) {\n            case PlayerEventTypes.playStart:\n                return PlayerEventTypePayloads.play;\n            case PlayerEventTypes.audioTrackChanged:\n            case PlayerEventTypes.textTrackChanged:\n                return PlayerEventTypePayloads.configure;\n\n            // because e.g. `timeupdate` events can happen while paused / playing, base the rest on state.\n            default: {\n                this.getEventTypePayloadFromEventState(playerEvent);\n            }\n        }\n    }\n}\n","import {PlayerLogProcessor} from './player-log-processor';\nimport {PlayerDeviceTypes, PlayerEventTypes, PlayerProperties, PlayingState, PlaySession} from '../models/player';\n\nexport class PlayerLoggerService {\n    private playerLogProcessor: PlayerLogProcessor;\n    protected playerProperties: PlayerProperties;\n    protected playSession: PlaySession;\n    protected intervalHandle = 0;\n\n    constructor(baseUrl: string, projectId: number) {\n        this.playerLogProcessor = new PlayerLogProcessor(baseUrl, projectId);\n        this.reset();\n    }\n\n    init() {\n        this.playerLogProcessor.init();\n    }\n\n    destroy() {\n        this.playerLogProcessor.destroy();\n    }\n\n    onStart(\n        pulseToken: string,\n        deviceType: PlayerDeviceTypes,\n        localTimeDelta: number,\n        isLive: boolean,\n        onStopCallback?: (appr: number) => void\n    ) {\n        this.reset();\n\n        this.playSession = {\n            pulseToken,\n            deviceType,\n            eventStack: [],\n            localTimeDelta,\n            isLive,\n            onStopCallback,\n        };\n    }\n\n    onCurrentTimeUpdated(currentTime: number) {\n        this.playerProperties.playPosition = currentTime;\n\n        if (this.playerProperties.mediaDuration > 0 && this.playerProperties.state !== PlayingState.idle) {\n            this.logEvent(PlayerEventTypes.timeupdate);\n        }\n    }\n\n    onDurationUpdated(duration: number) {\n        this.playerProperties.mediaDuration = duration;\n    }\n\n    onPlaying() {\n        if (this.playerProperties.state !== PlayingState.playing) {\n            if (this.playerProperties.state === PlayingState.idle) {\n                this.playerProperties.state = PlayingState.playing;\n                this.logEvent(PlayerEventTypes.playStart);\n                this.processPlaySession();\n                this.startInterval();\n            } else {\n                this.playerProperties.state = PlayingState.playing;\n                this.logEvent(PlayerEventTypes.playing);\n            }\n        }\n    }\n\n    onPause() {\n        if (this.playerProperties.state !== PlayingState.paused && this.playerProperties.state !== PlayingState.idle) {\n            this.playerProperties.state = PlayingState.paused;\n            this.logEvent(PlayerEventTypes.pause);\n        }\n    }\n\n    onError(error: string) {\n        if (this.playerProperties.state !== PlayingState.error) {\n            this.playerProperties.state = PlayingState.error;\n            this.playerProperties.error = error;\n            this.logEvent(PlayerEventTypes.error);\n        }\n    }\n\n    onStop() {\n        if (this.playerProperties.state !== PlayingState.idle) {\n            this.playerProperties.state = PlayingState.idle;\n            this.logEvent(PlayerEventTypes.stopped);\n            this.stopInterval();\n            this.processPlaySession();\n        }\n    }\n\n    onTextTrackChanged(textTrack: string) {\n        if (this.playerProperties.state === PlayingState.idle) {\n            return;\n        }\n        this.playerProperties.textTrack = textTrack;\n        this.logEvent(PlayerEventTypes.textTrackChanged);\n    }\n\n    onAudioTrackChanged(audioTrack: string) {\n        if (this.playerProperties.state === PlayingState.idle) {\n            return;\n        }\n        this.playerProperties.audioTrack = audioTrack;\n\n        this.logEvent(PlayerEventTypes.audioTrackChanged);\n    }\n\n    updateProperties(playerProperties: Partial<PlayerProperties>) {\n        this.playerProperties = {\n            ...this.playerProperties,\n            ...playerProperties,\n        };\n    }\n\n    protected startInterval() {\n        this.stopInterval();\n        // @ts-ignore\n        this.intervalHandle = setInterval(() => {\n            this.processPlaySession();\n        }, 30000);\n    }\n\n    protected stopInterval() {\n        if (this.intervalHandle) {\n            clearInterval(this.intervalHandle);\n        }\n    }\n\n    protected processPlaySession() {\n        this.playerLogProcessor.processPlaySession({...this.playSession}, this.getTimeStamp());\n        this.playSession.eventStack = [];\n    }\n\n    protected logEvent(eventType: PlayerEventTypes) {\n        if (this.playSession) {\n            this.playSession.eventStack.push({\n                ...this.playerProperties,\n                eventType,\n                timeStamp: this.getTimeStamp(),\n            });\n        }\n    }\n\n    protected reset() {\n        this.playSession = null;\n\n        this.playerProperties = {\n            state: PlayingState.idle,\n            error: null,\n            mediaDuration: 0,\n            playPosition: 0,\n            audioTrack: null,\n            textTrack: null,\n            resolution: null,\n        };\n    }\n\n    protected getTimeStamp() {\n        return Date.now() - (this.playSession ? this.playSession.localTimeDelta : 0);\n    }\n}\n"],"names":["ArticlePlayErrors","__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","graphRequest","apiFetchUrl","query","variables","token","fetch","method","headers","Accept","Authorization","body","JSON","stringify","then","response","json","MimeTypeHls","MimeTypeMp4","toFile","file","type","url","baseUrl","base_url","fileName","file_name","toMimeType","mimeType","console","warn","ApiService","constructor","projectId","this","setToken","getArticleAssetPlayConfig","articleId","assetId","continueFromPreviousPosition","protocols","data","errors","message","code","config","timeStamp","Date","parse","issued_at","entitlements","find","entitlement","encryption_type","filter","forEach","entitlementConfig","src","manifest","mime_type","isLive","is_live","protectionInfo","mediaProvider","media_provider","protocol","indexOf","authenticationToken","encryption_provider","keyDeliveryUrl","key_delivery_url","encryptionProvider","certificateUrl","fairplay_certificate_url","contentKeyId","replace","hls_key_uri","push","subtitles","map","item","srclang","locale","kind","label","locale_label","currentTime","appa","time_marker_end","pulseToken","pulse_token","article_id","asset_id","subtitleLocale","user_subtitle_locale","audioLocale","user_audio_locale","localTimeDelta","isNaN","now","aspectRatio","aspect_ratio","toPlayConfig","ArticleAssetPlay","getArticle","name","article","Article","metas","reduce","metaObj","value","posters","images","PlayingState","PlayerEventTypes","PlayerDeviceTypes","PlayerEventTypePayloads","PulseMode","PlayerLogProcessor","playLogs","apiCallInProgress","intervalHandle","apiUrl","init","setInterval","processFirstPlayLog","destroy","clearInterval","processPlaySession","playSession","eventStack","length","eventStackPayload","i","sumDelta","lastEventWasProcessed","currentEvent","isEventTypeWithoutTimeDelta","eventType","convertEventToEventPayload","previousEvent","state","createDeltaEventPayload","lastEvent","lastLogEvent","splice","MAX_EVENTS","event_type","error","event_payload","playLogPayload","getPlayerLogPayloadWithPulseToken","event_stack","pulse_mode","live","offline","device_type","deviceType","e","processPlayLog","currentLog","removePlayLog","logToSend","eventStackIndex","isStopCutOff","stop","catch","status","archive","log","logPayload","index","findIndex","textTrackChanged","audioTrackChanged","playStart","createBaseEventPayload","playerEvent","timestamp","playPosition","appr","Math","min","mediaDuration","resolution_tag","resolution","play","convertEventTypeToEventTypePayload","baseEvent","audio_locale","audioTrack","subtitle_locale","textTrack","timeDelta","getEventTypePayloadFromEventState","time_delta","playing","paused","buffering","loading","idle","configure","PlayerLoggerService","playerLogProcessor","reset","onStart","onStopCallback","onCurrentTimeUpdated","playerProperties","logEvent","timeupdate","onDurationUpdated","duration","onPlaying","startInterval","onPause","pause","onError","onStop","stopped","stopInterval","onTextTrackChanged","onAudioTrackChanged","updateProperties","getTimeStamp"],"sourceRoot":""}